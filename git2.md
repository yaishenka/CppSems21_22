# Вторая часть семинара по git

## Ветки

Пример рабочего процесса 

1) Есть стабильная рабочая версия проекта (master)
2) Есть свежая версия со всеми новыми фичами (dev)
3) Есть ветка под каждое новое изменение, где разработчики чет делают (feature...)

Собственно для поддержки такого функционала и существуют ветки (можно представить ваш репозиторий как некий граф)

Давайте разберемся как работать с ветками на простом примере. Пусть у нас есть проект и в нем есть только одна ветка (master) с несколькими коммитами.

### Создаем себе ветку для работы

Давайте создадим ветку и назовем ее task1

	git branch task1
	git checkout task1

или 

	git checkout -b task1

После этого наш локальный репозиторий переключится на эту новую ветку. Важное уточнение, ветка сейчас создана только в локальном репозитории!

### Переключение между ветками

Допустим нам срочно нужно пофиксить что-то в мастере

	git checkout master

Важно: если у вас есть какие-то незафиксированные изменения, то git не даст вам поменять ветку. Изменения можно:

1) Спрятать изменения (git stash)
2) Откатить изменения (git reset или git checkout -- file)
3) Коммитнуть изменения

Давайте создадим себе ветку для хотфикса

	git checkout -b hotfix123


Сделаем необходимые изменения и сделаем коммит. ТЕперь нам нужно влить наши изменения в мастер 

(В нормальной разработке вот в этом месте создается PR, но об этом попозже)

	git checkout master
	git merge hotfix

В этот раз гит на самом деле не сделает никаких дополнительных коммитов (fast-forward). Он просто переместит указатель ветки master вперед  (потому что наша ветка hotfix прямой потомок последнего коммита в master) 

Ветку hotfix можно удалить

	git branch -d hotfix 

(Пока мы не говорим об удаленном репозитории, говорим только про локальный)

Теперь мы можем вернуться к работе над task1

	git checkout task1 

Важно! Сейчас в task1 у нас нет нашего hotfix 

Можно 

1) Влить мастер в task1 (плохо)
2) Сделать git rebase master (подробней попозже)

### Основы слияния 

Допустим мы закончили работу над веткой task1. Давайте вольем изменения в мастер

	git checkout master
	git merge task1

Здесь git находит общего предка, потом создает новый коммит со всеми изменениями и добавляет его в master

#### Конфликт

Иногда (почти всегда) при слиянии у вас возникнет конфликт. Гит подскажет вам в каких файлах конфликт и сделает соответствующие пометки в них. 

После разрешения всех конфликтов надо сделать коммит.

### Пуш ветки в ориджин

Находясь в нужной ветке нужно юзнуть следующую команду

	 git push --set-upstream origin branch-name

## PR

(Автору искренне лень писать про это текст)

## rebase

### Простейшее применение

Допустим в master влили hotfix и он вам очень нужен в вашей ветке task1. (находимся на ветке task1)

У нас есть два способа: merge и rebase

Merge - плохо, потому что создает отдельный коммит и портит граф коммитов

Что делает rebase? Он передвигает начало вашей ветки task1 на голову мастера 

	git rebase master

### Редактирование коммитов 

	git rebase HEAD~3 -i

Автору опять лень

### Опасность rebase 

#### Перемещение коммитов, отправленных в публичный репозиторий 

Цитата с сайта git-scm.com:

Не перемещайте коммиты, уже отправленные в публичный репозиторий

Если вы будете придерживаться этого правила, всё будет хорошо. Если не будете, люди возненавидят вас, а ваши друзья и семья будут вас презирать.

Подробнее проблема описана [тут](https://git-scm.com/book/ru/v2/Ветвление-в-Git-Перебазирование)

На самом деле это нормальная практика ребейзить свою ветку

### rebase VS merge

(цитата с того же сайта)

Теперь, когда вы увидели перемещение и слияние в действии, вы можете задаться вопросом, что из них лучше. Прежде чем ответить на этот вопрос, давайте вернёмся немного назад и поговорим о том, что означает история.

Одна из точек зрения заключается в том, что история коммитов в вашем репозитории — это запись того, что на самом деле произошло. Это исторический документ, ценный сам по себе, и его нельзя подделывать. С этой точки зрения изменение истории коммитов практически кощунственно; вы лжёте о том, что на самом деле произошло. Но что, если произошла путаница в коммитах слияния? Если это случается, репозиторий должен сохранить это для потомков.

Противоположная точка зрения заключается в том, что история коммитов — это история того, как был сделан ваш проект. Вы не публикуете первый черновик книги или инструкции по поддержке вашего программного обеспечения, так как это нуждается в тщательном редактировании. Сторонники этого лагеря считают использование инструментов rebase и filter-branch способом рассказать историю проекта наилучшим образом для будущих читателей.

Теперь к вопросу о том, что лучше — слияние или перебазирование: надеюсь, вы видите, что это не так просто. Git — мощный инструмент, позволяющий вам делать многое с вашей историей, однако каждая команда и каждый проект индивидуален. Теперь, когда вы знаете, как работают оба эти приёма, выбор — какой из них будет лучше в вашей ситуации — зависит от вас.

При этом, вы можете взять лучшее от обоих миров: использовать перебазирование для наведения порядка в истории ваших локальных изменений, но никогда не применять его для уже отправленных куда-нибудь изменений.

## git fetch vs git pull

git fetch - подтягивает изменения из удаленного репозитория, но не применяет их

git pull - применяет изменения (по умолчанию делает merger)

## git reset

[тут](https://git-scm.com/book/ru/v2/Инструменты-Git-Раскрытие-тайн-reset) хорошо написано

## git cherry-pick


Берет конкретный коммит и применяет его к вашей ветке (создавая новый коммит)

## git revert

Команда git revert - полная противоположность git cherry-pick. Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.

