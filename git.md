# Seminar 3

### Git Version Control System

#### Основы

Git - система контроля версий. Главыные задачи, выполняемые системой контроля версий - версионирование (структурированное хранение истории разработки проекта) и коллаборация с другими разработчиками.

Git отслеживает изменения в файлах и директория, находящихся в корневой директории проекта. История храниться в папке **.git**, удалять её можно только если вы ТОЧНО знаете что делаете.

Предположим, вы зашли в директорию с инициализированым git репозиторием (то есть была выполнена комманда **git init**).

- Все файлы и директории в корневой директории называются **worktree** (workspace, рабочее дерево, рабочая директория). Это единственное место где можно легально руками менять файлы (не используя комманды гита)
  - С рабочей директорий вы работаете через обычный тектовый редактор
  - чтобы откатить файл к исходному состоянию моно использовать git **checkout** [path]. Для этого файл должен быть отслеживаемым
- После работы с кодом рабочей директории у вас могу измениться (включает в себя удаление) или появиться новые файлы. Для того, чтобы изменения были добавлены в историю проекта (**репозиторий**) из нужно сначала добавить в **индекс** (staging area). Может показаться. что этот шаг бесполезный, но существование индекса позволяет, например, не волноваться о существовании в директории временных файлов, которые мы не хотим добавлять в репозиторий.
  - git **add** [path] - добавляет изменения в индекс. Если path - путь к директории - добавляет изменения из всех файлов и поддиректорий директории. Флаг -A добавляет все изменения в индекс
  - git **rm**  **--cached** [path] - убирает изменения из индекса. работает аналогично git add
  - git **status** позволяет посмотреть, текущее состояние индекса и рабочей директории
- После того, как индекс соотвествует тем изменениям, которые мы хотим видеть в следующем **коммите** (можно думать, что коммит это копия нашего проекта в конкретный момент времени) он добавляется в репозиторий
  - git **commit** -m [message] - создать коммит с текстом message. При запуске без флага -m открывет текстовый редактор по умолчанию.  флаг --amend позволяет поменять последний коммит, вместо создания нового
- Также могут существовать другие копии репозитория на других машинах. Обычно **удалённый репозиторий** один и его принято называть **origin**
  - git **fetch** получить изменения в удалённом репозитории

![img](https://miro.medium.com/max/481/0*h0aOKyXxUmlS-dIK.png)

#### Конфигурация

Если вы только установили git то при попытке создать коммит гит попросит вас установаить имя и адрес электронной почты:

```
*** Please tell me who you are.

Run

  git config --global user.email "you@example.com"
  git config --global user.name "Your Name"

to set your account's default identity.
```

git **config** [key] [value] - устанавливает значения key в конфигурационном файле гита равным value.
При наличии флага --global - изменения будут применены для всей системы, иначе только для текущего репозитория.

Самые важные ключи:

- name - имя пользователя
- email - email
- core.editor - редатор по умолчанию
- autocrlf - необходима для работы между виндой и unix подобными системами

#### Ветки

Все коммиты в репозитории образуют направленный ацикличный граф. Каждый коммит указывает на своих родителей (их может быть несколько) и ничего не знает про своих потомков.

Более того, у каждого коммита есть уникальный идентификатор. Выглядит он как-то так: **fa5a8bc31e82433036db7b...**

Для того, чтобы посмотреть историю коммитов можно использовать комманду git **log**. Сверху будут самые новые коммиты.

Если индекс и рабочая директория пусты - мы можем перейти с одного коммита на другой. Для этого используется комманда git **checkout** [commit], где commit - это уникальный идентификатор коммита, в который мы хотим попасть. После выполнения этой команды в рабочей директории будет копия проекта сохранённая в коммите commit.

Однако ссылаться на коммиты по их идентификатору не удобно. Для этого в гите сущетсвуют ветки. Ветка - это указатель на коммит, она состоит из человекочитаемого (пожалуйста) имени и идентификатора коммита. При инициализации репозитория создаётся ветка мастер (которая изначально никуда не ссылается, поскольку никаких коммитов ещё нет).

Перейти на коммит на который ссылается ветка можно при помощи комманды git **checkout** [branch-name]. После перехода в ветку в **находитесь на этой ветке** (git status напишет *on branch [branch-name]*)

При создании нового коммита ветка **на который находится пользователь** будет указывать на **НОВЫЙ** коммит.

- git **checkout -b** [branch-name] - создать новую ветку и перейти в неё
- git **branch -d** [branch-name] - удалить ветку (коммиты никуда не пропадают!!!)
- git **branch --all** - вывести список всех веток
- git **reset --hard** [commit] - перенести текущую ветку на коммит commit

[![GitHub & GIT Tutorial](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fblog.seibert-media.net%2Fwp-content%2Fuploads%2F2015%2F07%2FGit-Branches-1.png&f=1&nofb=1)](https://blog.seibert-media.net/wp-content/uploads/2015/07/Git-Branches-1.png)

В случае, когда мы реализовали какую-то функциональность в отдельной ветке (feature) и мы хотим этот функционал в главную ветку (master) необходимо произвести **слияние** (merge) веток.

- Для этого необходимо вызвать git **merge** [feature-branch] находять в [master-branch]

- Если git'у не удалось самостоятельно понять, что по итогу получится в конкретном браузере - необходимо будет разрешить конфликты слияния. Конфликты обозначены в файлах следующим образом:

- ```
  <<<<<<< HEAD
  Adding some content to mess with it later
  Append this text to initial commit
  =======
  Changing the contents of text file from feature branch
  >>>>>>> feature
  ```

- Для того чтобы продожлить нужно разрешить конфликт, например следующим образом:

- ```
  Adding some content to mess with it later
  Append this text to initial commit
  Changing the contents of text file from feature branch
  ```

- Добавить файл с разрешёнными конфликтами через git add

- Закончить слияние вызовом git commit

[![Git Merge | Atlassian Git Tutorial](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwac-cdn.atlassian.com%2Fdam%2Fjcr%3A83323200-3c57-4c29-9b7e-e67e98745427%2FBranch-1.png%3FcdnVersion%3Djo&f=1&nofb=1)](https://wac-cdn.atlassian.com/dam/jcr:83323200-3c57-4c29-9b7e-e67e98745427/Branch-1.png?cdnVersion=jo)

#### Работа с удалённым репозиторием

- git **push** - отправить изменения из текущей ветки в удалённый репозиторий
- Если ветка не существует в удалённом репозитории - git **push --set-upstream-to** [origin]/[branch-name]
- git **push** - добавить изменения из удалённой ветки в локальную

#### Другие функции

- git **diff** [from-commit] [to-commit] - показать изменения между коммитами

